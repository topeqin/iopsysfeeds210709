#!/bin/sh /etc/rc.common

. /lib/functions.sh
include /lib/network

START=20
USE_PROCD=1

DEVICE_ADDED=0

device_config_exists() {
	ubus call uci get '{"config":"network","type":"device"}' | grep -w name | grep -qw "$1" && return 0
	return 1
}

configure_untagged_vlan() {
	local name="$1"
	local device="$2"
	local ifname="$3"

	[ -n "$ifname" -a -n "$name" ] || return
	device_config_exists "$ifname" && return

	uci -q set network.$name=device
	uci -q set network.$name.type=untagged
	uci -q set network.$name.ifname="$device"
	uci -q set network.$name.name="$ifname"
	uci -q commit network

	DEVICE_ADDED=1
}

# ATM #
check_pvc() {
	local vpi=$1
	local vci=$2
	local ret

	ret=$(xtmctl operate conn --show | awk -v test="$vpi/$vci" '{if ($3==test ) print $5 }')

	case $ret in
		''|*[!0-9]*) return 0 ;;
		*) return $ret ;;
	esac
}

check_xtm_list() {
	local qclass=$1
	local pcr scr mbs
	local ret

	case $# in
		1)
			pcr=0
			scr=0
			mbs=0
		;;
		2)
			pcr=$2
			scr=0
			mbs=0
		;;
		4)
			pcr=$2
			scr=$3
			mbs=$4
		;;
	esac

	ret=$(xtmctl operate tdte --show | awk -v test="$qclass" -v pcr="$pcr" -v scr="$scr" -v mbs="$mbs" '{if ($2==test && $3==pcr && $4==scr && $5==mbs ) print $1 }')

	case $ret in
		''|*[!0-9]*) return 0 ;;
		*) return $ret ;;
	esac
}

configure_atm_device() {
	local name vpi vci device link_type encapsulation qos_class pcr mbs scr

	config_get name $1 name "ATM"
	config_get vpi $1 vpi "8"
	config_get vci $1 vci "35"
	config_get device $1 device "atm0"
	config_get link_type $1 link_type "eoa"
	config_get encapsulation $1 encapsulation "llc"
	config_get qos_class $1 qos_class "ubr"
	config_get pcr $1 pcr
	config_get mbs $1 mbs
	config_get scr $1 scr

	check_pvc $vpi $vci
	ret=$?

	if [ "$ret" -eq 0 ]; then
		check_xtm_list $qos_class $pcr $scr $mbs
		ret=$?

		if [ "$ret" -eq 0 ]; then
			case $qos_class in # ubr, cbr, gfr, vbr-nrt, vbr-rt, ubr+, abr
				ubr)
					xtmctl operate tdte --add "$qos_class"
				;;
				ubr_pcr|ubr+)
					xtmctl operate tdte --add "$qos_class" $pcr
				;;
				cbr)
					xtmctl operate tdte --add "$qos_class" $pcr
				;;
				nrtvbr|vbr-nrt)
					xtmctl operate tdte --add "$qos_class" $pcr $scr $mbs
				;;
				rtvbr|vbr-rt)
					xtmctl operate tdte --add "$qos_class" $pcr $scr $mbs
				;;
				gfr)
				;;
				abr)
				;;
			esac
		fi

		case $link_type in # EoA, IPoA, PPPoA, CIP
			EoA|eoa)
				[ $encapsulation == "vcmux" ] && encapsulation="vcmux_eth" || encapsulation="llcsnap_eth"
			;;
			PPPoA|pppoa)
				[ $encapsulation == "vcmux" ] && encapsulation="vcmux_pppoa" || encapsulation="llcencaps_ppp"
			;;
			IPoA|ipoa)
				[ $encapsulation == "vcmux" ] && encapsulation="vcmux_ipoa" || encapsulation="llcsnap_rtip"
			;;
			CIP|cip)
			;;
		esac

		check_xtm_list $qos_class $pcr $scr $mbs
		ret="$?"

		xtmctl operate conn --add 1.$vpi.$vci aal5 $encapsulation 0 1 $ret
		xtmctl operate conn --addq 1.$vpi.$vci 0 wrr 1 dt # low  priority queue
		xtmctl operate conn --addq 1.$vpi.$vci 1 wrr 1 dt # mid  priority queue upstream ACK's and ping from LAN will use this queue
		xtmctl operate conn --addq 1.$vpi.$vci 7 wrr 1 dt # high priority queue, internal traffic dhcp igmp dns and icmp
		xtmctl operate conn --createnetdev 1.$vpi.$vci $device
		xtmctl operate intf --state 1 enable

		configure_untagged_vlan "$name" "$device" "$device.1"
		[ $DEVICE_ADDED -eq 1 ] && ubus call network reload
	fi
}

remove_atm_devices() {
	local vpi vci rest
	local vpivci=`xtmctl operate conn --show | grep "ATM\|mode" | awk '{if (NR!=1 && $1!="PTM") {print $3}}'`

	for i in $vpivci
	do
		rest=${i#\/}
		vpi=${rest%%\/*}
		vci=${rest#*\/}
		echo "xtmctl operate conn --delete 1.$vpi.$vci"
		xtmctl operate conn --delete 1.$vpi.$vci
		echo "xtmctl operate conn --deletenetdev 1.$vpi.$vci"
		xtmctl operate conn --deletenetdev 1.$vpi.$vci
	done
}

create_atm_devices() {
	echo "Creating ATM Device(s)"
	config_load dsl
	config_foreach configure_atm_device atm-device
}
# ATM END #

# PTM #
check_ptm() {
	local ret
	local ptmprio=$1
	local dslat=$2

	if [ "$ptmprio" -eq 2 ]; then
		ptmprio="high"
	else
		ptmprio="low"
	fi

	ret=$(xtmctl operate conn --show | awk -v dslat="$dslat" -v ptmprio="$ptmprio" '{if ($2 == dslat && $3 == ptmprio ) print $2 }')

	case $ret in
		''|*[!0-9]*) return 0 ;;
		*) return $ret ;;
	esac
}

configure_ptm_device() {
	local name device priority portid

	config_get name $1 name "PTM"
	config_get device $1 device "ptm0"
	config_get priority $1 priority 1
	config_get portid $1 portid 1

	check_ptm $priority $portid
	ret=$?

	if [ "$ret" -eq 0 ]; then
		xtmctl operate conn --add $portid.$priority
		xtmctl operate conn --addq $portid.$priority 0 wrr 1 dt -1 -1 3000 # low  priority queue
		xtmctl operate conn --addq $portid.$priority 1 wrr 1 dt -1 -1 3000 # mid  priority queue upstream ACK's and ping from LAN will use this queue
		xtmctl operate conn --addq $portid.$priority 7 wrr 1 dt -1 -1 3000 # high priority queue, internal traffic dhcp igmp dns and icmp
		echo "xtmctl operate conn --createnetdev $portid.$priority $device"
		xtmctl operate conn --createnetdev $portid.$priority $device
		xtmctl operate intf --state 1 enable

		configure_untagged_vlan "$name" "$device" "$device.1"
		[ $DEVICE_ADDED -eq 1 ] && ubus call network reload
	fi
}

remove_ptm_devices() {
	local delptm
	local x=0

	IFS=$'\n'
	for i in `xtmctl operate conn --show | grep "PTM\|mode"`
	do
		if [ $x -eq 1 ]; then
			delptm=$(echo $i | awk '{if ($1!="ATM") print $2"."$11}')
			echo "xtmctl operate conn --delete $delptm"
			xtmctl operate conn --delete $delptm
			xtmctl operate conn --deletenetdev $delptm
		fi
		x=1
	done
	unset IFS
}

create_ptm_devices() {
	echo "Creating PTM Device(s)"
	config_load dsl
	config_foreach configure_ptm_device ptm-device
}
# PTM END #

prioritize_arp()
{
      ebtables -t nat -D POSTROUTING -j mark --mark-or 0x7 -p ARP >/dev/null
      ebtables -t nat -A POSTROUTING -j mark --mark-or 0x7 -p ARP >/dev/null
}

remove_devices() {
	remove_atm_devices
	remove_ptm_devices
}

create_devices() {
	local tpstc="$(xdslctl info --show | grep TPS-TC)"
	if echo "$tpstc" | grep -q "ATM Mode"; then
		create_atm_devices
	elif echo "$tpstc" | grep -q "PTM Mode"; then
		create_ptm_devices
	fi
}

start_dsl() {
	local VDSL=0
	local GFAST=0
	local mod=""
	local modes=""
	local profile=""

	config_load dsl

	# Modes
	config_get mode line mode
	for mod in $mode; do
		[ $mod == "gdmt" ] && "${modes}d"
		[ $mod == "glite" ] && modes="${modes}l"
		[ $mod == "t1413" ] && modes="${modes}t"
		[ $mod == "adsl2" ] && modes="${modes}2"
		[ $mod == "adsl2p" ] && modes="${modes}p"
		[ $mod == "annexl" ] && modes="${modes}e"
		[ $mod == "annexm" ] && modes="${modes}m"
		[ $mod == "vdsl2" ] && modes="${modes}v" && VDSL=1
		[ $mod == "gfast" ] && modes="${modes}f" && GFAST=1
	done

	# VDSL Profiles
	config_get profile line profile
	profile="$(echo $profile | sed 's/35b/BrcmPriv1/g')"

	# Capabilities
	config_get_bool bitswap line bitswap 1
	[ $bitswap -eq 1 ] && bitswap="on" || bitswap="off"
	config_get_bool sra line sra 1
	[ $sra -eq 1 ] && sra="on" || sra="off"
#	config_get_bool trellis line trellis 1
#	config_get_bool sesdrop line sesdrop 1
	# VDSL2 only
	config_get_bool us0 line us0 1
	[ $us0 -eq 1 ] && us0="on" || us0="off"
#	config_get_bool dynamicd line dynamicd 1
#	config_get_bool dynamicf line dynamicf 1
#	config_get_bool sos line sos 1


	echo "Starting DSL"

	xtmctl start
	xtmctl operate intf --state 1 enable

	if [ $VDSL -eq 1 -o $GFAST -eq 1 ]; then
		echo "xdslctl start --up --mod $modes --profile "$profile" --sra $sra --bitswap $bitswap --us0 $us0"
		xdslctl start --up --mod $modes --profile "$profile" --sra $sra --bitswap $bitswap --us0 $us0
	else
		echo "xdslctl start --up --mod $modes --sra $sra --bitswap $bitswap"
		xdslctl start --up --mod $modes --sra $sra --bitswap $bitswap
	fi

	if [ $GFAST -eq 1 ]; then
		# enable V43 tone set for GFAST
		echo "xdslctl configure1 --phycfg 0 0 0 0 0 0 0 0 0 0 0 0x400000 0x400000"
		xdslctl configure1 --phycfg 0 0 0 0 0 0 0 0 0 0 0 0x400000 0x400000
	fi
}

# CONVERT OLD CONFIG #
convert_old_atm() {
	local name ifname baseifname
	local vpi vci link_type atmtype pcr scr mbs
	local encapseoa encapspppoa encapsipoa encapsulation

	config_get atmtype $1 atmtype "ubr"
	config_get link_type $1 link_type "EoA"
	config_get pcr $1 pcr
	config_get scr $1 scr
	config_get mbs $1 mbs
	config_get vpi $1 vpi "8"
	config_get vci $1 vci "35"
	config_get encapseoa $1 encapseoa
	config_get encapspppoa $1 encapspppoa
	config_get encapsipoa $1 encapsipoa
	config_get baseifname $1 baseifname "atm0"
	config_get name $1 name "ATM$vpi$vci"

	uci -q set dsl.$baseifname=atm-device
	uci -q set dsl.$baseifname.name="$name"
	uci -q set dsl.$baseifname.device="$baseifname"
	uci -q set dsl.$baseifname.qos_class="$atmtype"
	uci -q set dsl.$baseifname.vpi="$vpi"
	uci -q set dsl.$baseifname.vci="$vci"
	uci -q set dsl.$baseifname.pcr="$pcr"
	uci -q set dsl.$baseifname.mbs="$mbs"
	uci -q set dsl.$baseifname.scr="$scr"

	case $link_type in
		EoA)
			uci -q set dsl.$baseifname.link_type="eoa"
			[ "$encapseoa" == "vcmux_eth" ] && encapsulation="vcmux" || encapsulation="llc"
			uci -q set dsl.$baseifname.encapsulation="$encapsulation"
		;;
		PPPoA)
			uci -q set dsl.$baseifname.link_type="pppoa"
			[ "$encapspppoa" == "vcmux_pppoa" ] && encapsulation="vcmux" || encapsulation="llc"
			uci -q set dsl.$baseifname.encapsulation="$encapsulation"
		;;
		IPoA)
			uci -q set dsl.$baseifname.link_type="ipoa"
			[ "$encapsipoa" == "vcmux_ipoa" ] && encapsulation="vcmux" || encapsulation="llc"
			uci -q set dsl.$baseifname.encapsulation="$encapsulation"
		;;
	esac
}

convert_old_ptm() {
	local name ifname baseifname
	local dslat ptmprio

	config_get name $1 name "PTM"
	config_get baseifname $1 baseifname "ptm0"
	config_get dslat $1 dslat
	config_get ptmprio $1 ptmprio

	uci -q set dsl.$baseifname=ptm-device
	uci -q set dsl.$baseifname.name="$name"
	uci -q set dsl.$baseifname.device="$baseifname"
	uci -q set dsl.$baseifname.priority="$ptmprio"
	uci -q set dsl.$baseifname.portid="$dslat"
}

convert_old_dsl() {
	local cap

	sed -i 's/Enabled/1/g' /etc/config/layer2_interface
	sed -i 's/Disabled/0/g' /etc/config/layer2_interface


	uci -q delete dsl.line.mode
	uci -q delete dsl.line.profile
	uci -q delete dsl.line.us0
	uci -q delete dsl.line.sra
	uci -q delete dsl.line.bitswap

	config_load layer2_interface
	# Mode
	config_get_bool cap capabilities GDmt 1
	[ $cap -eq 1 ] && uci -q add_list dsl.line.mode=gdmt
	config_get_bool cap capabilities Glite 1
	[ $cap -eq 1 ] && uci -q add_list dsl.line.mode=glite
	config_get_bool cap capabilities T1413 1
	[ $cap -eq 1 ] && uci -q add_list dsl.line.mode=t1413
	config_get_bool cap capabilities ADSL2 1
	[ $cap -eq 1 ] && uci -q add_list dsl.line.mode=adsl2
	config_get_bool cap capabilities ADSL2plus 1
	[ $cap -eq 1 ] && uci -q add_list dsl.line.mode=adsl2p
	config_get_bool cap capabilities AnnexL 1
	[ $cap -eq 1 ] && uci -q add_list dsl.line.mode=annexl
	config_get_bool cap capabilities AnnexM 1
	[ $cap -eq 1 ] && uci -q add_list dsl.line.mode=annexm
	config_get_bool cap capabilities VDSL2 1
	[ $cap -eq 1 ] && uci -q add_list dsl.line.mode=vdsl2
	config_get_bool cap capabilities GFast 0
	[ $cap -eq 1 ] && uci -q add_list dsl.line.mode=gfast

	# Profile
	config_get_bool cap capabilities 8a 1
	[ $cap -eq 1 ] && uci -q add_list dsl.line.profile=8a
	config_get_bool cap capabilities 8b 1
	[ $cap -eq 1 ] && uci -q add_list dsl.line.profile=8b
	config_get_bool cap capabilities 8c 1
	[ $cap -eq 1 ] && uci -q add_list dsl.line.profile=8c
	config_get_bool cap capabilities 8d 1
	[ $cap -eq 1 ] && uci -q add_list dsl.line.profile=8d
	config_get_bool cap capabilities 12a 1
	[ $cap -eq 1 ] && uci -q add_list dsl.line.profile=12a
	config_get_bool cap capabilities 12b 1
	[ $cap -eq 1 ] && uci -q add_list dsl.line.profile=12b
	config_get_bool cap capabilities 17a 1
	[ $cap -eq 1 ] && uci -q add_list dsl.line.profile=17a
	config_get_bool cap capabilities 30a 1
	[ $cap -eq 1 ] && uci -q add_list dsl.line.profile=30a
	config_get_bool cap capabilities 35b 0
	[ $cap -eq 1 ] && uci -q add_list dsl.line.profile=35b

	# Capability
	config_get_bool cap capabilities US0 1
	uci -q set dsl.line.us0=$cap
	config_get_bool cap capabilities bitswap 1
	uci -q set dsl.line.bitswap=$cap
	config_get_bool cap capabilities sra 1
	uci -q set dsl.line.sra=$cap
}

convert_old_config() {
	[ -f /etc/config/dsl ] || touch /etc/config/dsl

	# DSL
	if uci -q get layer2_interface.capabilities >/dev/null; then
		convert_old_dsl
	fi
	
	# ATM Devices
	if uci -q get layer2_interface_adsl.@atm_bridge[0] >/dev/null; then
		config_load layer2_interface_adsl
		config_foreach convert_old_atm atm_bridge
	fi

	# PTM Devices
	if uci -q get layer2_interface_vdsl.@vdsl_interface[0] >/dev/null; then
		config_load layer2_interface_vdsl
		config_foreach convert_old_ptm vdsl_interface
	fi

	uci -q commit dsl

#	rm -f /etc/config/layer2_interface
#	rm -f /etc/config/layer2_interface_adsl
#	rm -f /etc/config/layer2_interface_vdsl
}
# CONVERT OLD CONFIG END#

start_service() {
	create_devices
}

stop_service() {
	remove_devices

	# echo "Stopping DSL"
	# stop causes IRQ issues
	# xdslctl stop
}

boot() {
	local HASADSL="$(db -q get hw.board.hasAdsl)"
	local HASVDSL="$(db -q get hw.board.hasVdsl)"
	[ "$HASADSL" == "1" -o "$HASVDSL" == "1" ] || return

	convert_old_config

	prioritize_arp
	start_dsl

	start
}

reload_service() {
	stop
	start
}

service_triggers() {
        procd_add_reload_trigger dsl layer2_interface layer2_interface_adsl layer2_interface_vdsl
}

