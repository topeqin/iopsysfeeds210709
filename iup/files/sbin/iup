#!/bin/sh

echo $$ > /var/run/iup.pid

. /lib/functions.sh
. /lib/functions/network.sh
. /usr/share/libubox/jshn.sh

include /lib/upgrade
include /lib/network

export IUPCONFFILES=/tmp/iup/sysupgrade.conffiles.tar.gz
export IUPMD5=/etc/configchecksums
export CONFILESLURP='/tmp/iup/*.conf'
export IUPTEMP="/tmp/iup"
export INTERACTIVE=0
export VERBOSE=0
export CONF=1
export DESKEY=$(cat /proc/nvram/DesKey | tr -d '\n' | hexdump -e '16/1 "%02x"')
export MAC=$(cat /proc/nvram/BaseMacAddr)
export RANGE=10
export RETRYSTOP=5
export SLEEP=10
#remove whitespace
MAC=${MAC// /}
#lower to upper Conversion
MAC=$(echo $MAC | tr '[a-z]' '[A-Z]')

v() {
	[ "$VERBOSE" -ge 1 ] && logger -s -t $0[$$] "$@" 2>&1 | tee /dev/console
}

handle_ucitrack()
{
	local config="$1"
	config_get init "$config" init
	echo $init
	config_get affects "$config" affects

	for aff in $affects
	do
		config_foreach handle_ucitrack $aff
	done
}

get_packages()
{
	local pack
	pack=$(grep -w 'package' $1)
	pack=${pack//package/}
	#pack=${pack//[\'|\"]/}
	echo $pack | tr -d '\"' | tr -d "'"
}

reload ()
{
	local reload
	local initlist
	local reload
	local pack
	pack=$(get_packages $1)
	config_load ucitrack
	for packname in $pack
	do
		initlist=$(config_foreach handle_ucitrack $packname)
		for reltest in $initlist
		do
			case $reload in
				*" $reltest "*) v "already added to reload $reltest" ;;
				*) reload="$reload"" ""$reltest" ;;
			esac
		done
	done
	v "Init scripts to be run $reload"
	for inittoreload in $reload
	do
		if [ "$inittoreload" != "iup" ]; then
			/etc/init.d/$inittoreload restart
		fi
	done
	#Ugly hack need to figure out something here
	test_default_route
	if [ "$?" -eq 1 ]; then
		sleep 5
	fi
}

handle_provisioning() {
	local config="$1"
	local default="$2"
	local enabled
	local url
	local tftpfile
	local host
	local md5
	local defaultreset
	local pack
	local packname
	local number=$RANDOM
	local retry=1
	local number
	local incsleep=$SLEEP
	let "number %= $RANGE"
	if [[ ! -e $IUPTEMP ]]; then
		mkdir $IUPTEMP
	fi
	touch $IUPCONFFILES
	config_get_bool enabled "$config" enabled "$default"
	config_get_bool defaultreset "$config" defaultreset
	config_get deckey "$config" deckey
	if [ "$enabled" -eq 1	]; then
		if [ "$config" == "iup" ]; then
			v "using url from dhcp options"
			config_get url "$config" urliup
		else
			config_get url "$config" url
		fi
		url=${url//\$MAC/$MAC}
		v "Download from $url"

		while [ $retry -le $RETRYSTOP ]
		do
		  if [ ${url%%:*} == "tftp" ]; then
			tftpfile=${url#*\/\/}
			host=${tftpfile%%\/*}
			tftpfile=${tftpfile#*\/}

			/usr/bin/tftp -l $IUPCONFFILES -r "$tftpfile" -g "$host"
		  else
			get_image "$url" "cat" > $IUPCONFFILES
		  fi
		  if [ -s $IUPCONFFILES ]; then
			v "File Downloaded"
			retry=$((RETRYSTOP + 1))
		  v "Download failed will try again in $incsleep sec"
		  else
		  sleep $incsleep
		  incsleep=$((incsleep * retry + number))
		  retry=$((retry+1))
		  fi
		done
	fi
	if [ ! -s "$IUPCONFFILES" ]; then
		echo "File not Found"
		reboot="off"
		CONF=0
	else
		handle_Downloaded_file $deckey
	fi
}

handle_Downloaded_file()
{
	local DECKEY
	local KEY
	[ -n "$1" ] && DECKEY=$(echo $1 | tr -d '\n' | hexdump -e '16/1 "%02x"')
	KEY=${DECKEY:-$DESKEY}
	local img_type
	case "$(get_image_type "$IUPCONFFILES")" in
                "INTENO") img_type=2 ;;
                "CFE+FS") img_type=1 ;;
                "FS")     img_type=0 ;;
                *)      img_type="UNKNOWN";;
        esac

        if [ "$img_type" == "UNKNOWN" ] ; then
		case "$(hexdump -v -n 2 -e '1/1 "%02x"' $IUPCONFFILES)" in
			1f8b)
				v "Found Config"
				md5=$(md5sum $IUPCONFFILES)
				md5="${md5%% *}" # remove the first space and everything after it
				md5sum "$IUPCONFFILES" >> "$IUPMD5.temp"
				if grep -q "$md5" "$IUPMD5"; then
					v "Config Already Up to Date"
					#because config is up to date we need to disable last step reboot if set
					reboot="off"
					rm -rf $IUPTEMP
				else
					cd $IUPTEMP
					tar xvzf $IUPCONFFILES
					for f in $CONFILESLURP
					do
						v "file to be applied $f and config $(cat $f)"
						uci import -f $f
					done
					pack=$(get_packages $CONFILESLURP)
					v "$pack packages to be commited"
					for packname in $pack
					do
						uci commit $packname
					done
					reboot=`uci -q  get provisioning.configserver.reboot`
					if [ "$reboot" != "on" ]; then
						reload $CONFILESLURP
					fi
					rm -rf $IUPTEMP

					cp /rom/etc/uci-defaults/* /etc/uci-defaults/
					sync
				fi
			;;
			*)
				v "encrypted"
				if [ $KEY ]; then
					openssl enc -d -des-ede -nosalt -K $KEY -iv "0000000000000000" -in $IUPCONFFILES -out $IUPCONFFILES.tmp
					if [ $? -eq 0 ]; then
						v "Decrypted Content"
						mv $IUPCONFFILES.tmp $IUPCONFFILES
						handle_Downloaded_file
					else
						v "Decryption Failed! Exiting"
						rm -rf $IUPTEMP
						exit 1
					fi
				else
					v "No Key Defined"
					rm -rf $IUPTEMP
					exit 1
				fi
			;;
		esac
	else
		v "Image found will start flashing"
		if [ "$defaultreset" -eq 1 ]; then
			v "nuke config"
			 /sbin/sysupgrade -v -n $IUPCONFFILES
		else
			/sbin/sysupgrade -v $IUPCONFFILES
		fi
	fi
}

# function: change_to_vlan
# arg 1 = vlan id
# arg 2 = vlan priority
# arg 3 = $INTERFACE
change_to_vlan() {
	# local variables.
	local name="vlan$1"	# construct name = vlan + vlanid.
	local base_dev		# varible holding device name of wan port.
	local wan_if		# variable holding wan interfaces.
	local new_wan_if	#

	# extract device name.
	network_get_device base_dev $3

	# bring down old interface/device.
	ifdown "${base_dev}"
	logger -t dhcp_opt132 "bringing down old if: ${base_dev}"

	# extract base name of device.
	base_dev=$(echo ${base_dev} | cut -d. -f1)

	# add "VLAN interface" to the "end of the file".
	uci add layer2_interface_vlan vlan_interface
	uci set layer2_interface_vlan.@vlan_interface[-1].name=${name}
	uci set layer2_interface_vlan.@vlan_interface[-1].vlan8021q=${1}
	uci set layer2_interface_vlan.@vlan_interface[-1].vlan8021p=${2}
	uci set layer2_interface_vlan.@vlan_interface[-1].ifname="${base_dev}.${1}"
	uci set layer2_interface_vlan.@vlan_interface[-1].baseifname=${base_dev}
	# and commit the change.
	uci commit layer2_interface_vlan
	logger -t dhcp_opt132 "committed update to file layer2_interface_vlan"

	# reload configuration files.
	/etc/init.d/layer2_interface_vlan reload
	logger -t dhcp_opt132 "reload layer2_interface_vlan config"

	# replace old interface (like eth0.1 with new eth0.101).
	wan_if=$(uci get network.$3.ifname)
	logger -t dhcp_opt132 "old network.${3}.ifname: $wan_if"

	# loop through the string, remove any word close to "base_dev".
	for word in ${wan_if}; do
	#echo $word
	case $word in
		${base_dev}*) # don't add if.
		;;
		*)	new_wan_if=${word}' '${new_wan_if}  # add if.
			#new_wan_if+=" ${word}"  # probably not working in ash.
		;;
	esac
	done
	# append new interface.
	new_wan_if=${new_wan_if}${base_dev}.${1}
	uci set network.wan.ifname="${new_wan_if}"
	# and commit the change.
	uci commit network
	logger -t dhcp_opt132 "committed update to file network: ifname=${new_wan_if}"

	# reboot into new if configuration.
	v "Rebooting"
	export REBOOT_REASON=iup
	/sbin/reboot
}

handle_option224()
{
	if [ -z "$1" ] ; then
		echo "No argument"
		return 1
	fi

	if [ $(echo $1|grep -o "," | wc -l) -eq 0 ] ; then
		url=$1
	else
		url=$(echo $1|cut -d',' -f1)
		a=$(echo $1|cut -d',' -f2)
		b=$(echo $1|cut -d',' -f3)
		c=$(echo $1|cut -d',' -f4)
	fi

	currdate=$(date +"%Y-%m-%d")

	active=0
	if [ -z $a ] ; then
		active=1
	elif [ $a ] && [ $b ] && [ $a -lt 25 ] ; then
		#Time
		begin=$(date +%s -d"$currdate $a")
		now=$(date +%s)
		end=$((begin+3600*$b))
		if [ $now -gt $begin ] && [ $now -lt $end ] ; then
			active=1
		fi
	elif [ $a ] && [ $b ] && [ $c ] && [ $a -gt 25 ]  ; then
		#Date
		y=$(echo $a| cut -c1-4)
		m=$(echo $a| cut -c5-6)
		d=$(echo $a| cut -c7-8)
		begin=$(date +%s -d"$y-$m-$d $b")
		now=$(date +%s)
		end=$((begin+3600*$c))
		if [ $now -gt $begin ] && [ $now -lt $end ] ; then
			active=1
		fi
	else
		echo "Bad format"
		return 1
	fi

	softwareminuspath=${url##*/}

	if [ $url ] && [ $active -eq 1 ]; then
		echo "Software version to download $softwareminuspath"
		local sysinfo=$(ubus call router.system info)
		json_load "$sysinfo"
		json_select system
		json_get_var firmware firmware
		local firmware_new=${softwareminuspath%.*}	# remove extension (.w, .y or .y2) from filename
		if [ "$firmware_new" != "$firmware" ] ; then
			echo "Image found $url will start flashing"
			wait_for_dns $url
			/sbin/sysupgrade -v $url &
			return 1
		else
			echo "Will not update software, already up to date"
			return 0
		fi
	fi
}

### MAIN ###
while [ -n "$1" ]; do
	case "$1" in
		-v) export VERBOSE="$(($VERBOSE + 1))";;
		-q) export VERBOSE="$(($VERBOSE - 1))";;
		-*)
			echo "Invalid option: $1"
			exit 1
		;;
		*) break;;
	esac
	shift;
done

if [ -f $IUPMD5 ]; then
	v "File $IUPMD5 exists"
else
	v "File $IUPMD5 did not exists"
	touch $IUPMD5
fi

# Process IUP related DHCP options #
if [ -n "$1" ]; then
	local privopt224 privopt225 privopt226 vendorspecinf httpurl128
	local tftp bootfile vlanid vlanpriority interface

	json_load "$1"
	json_get_var interface interface
	json_get_var privopt224 privopt224
	json_get_var privopt225 privopt225
	json_get_var privopt226 privopt226
	json_get_var vendorspecinf vendorspecinf
	json_get_var httpurl128 httpurl128
	json_get_var tftp tftp
	json_get_var bootfile bootfile
	json_get_var vlanid vlanid
	json_get_var vlanpriority vlanpriority

	if [ $privopt224 ]; then
		echo "Option224 recived " $privopt224 > /dev/console
		handle_option224 $privopt224
		[ $? -eq 1 ] && exit
	fi

	if [ $vendorspecinf ]; then
		url=${vendorspecinf%%,*}; rest=${vendorspecinf#*,}
		provisioningcode=${rest%%,*};
		uci_set_state provisioning iup url "$url"
		uci_set_state provisioning iup provisioningcode "$provisioningcode"
	elif [ $httpurl128 ]; then
		uci_set_state provisioning iup urliup "$httpurl128"
	elif [ $tftp ]; then
		if [ ${bootfile:0:1} == '/' ]; then
			uci_set_state provisioning iup urliup "tftp://$tftp$bootfile"
		else
			uci_set_state provisioning iup urliup "tftp://$tftp/$bootfile"
		fi
	fi

	# if we get vlanid and maybe vlanpriority, configure for that.
	if [ -n "$vlanid" -a -n "$vlanpriority" ]; then
		logger -t dhcp_opt132 "vlanid: ${vlanid}, vlanpriority: ${vlanpriority}"
		change_to_vlan ${vlanid} ${vlanpriority} ${interface}
	elif [ -n "$vlanid" ]; then
		logger -t dhcp_opt132 "vlanid: ${vlanid}"
		change_to_vlan ${vlanid} 0 ${interface}
	elif [ -n "$privopt225" ] || [ -n "$privopt226" ]; then
		# opt225 and opt226 can be used together or separatly
		if [ -n "$privopt225" ]; then
			echo "dhcp option 225: $privopt225" >/dev/console
			# option225 is allowd to change only once per CPE
			if [ "$(uci get -q ice.cloud.frozen)" != "1" ] ; then
				uci set ice.cloud.frozen="1"
				uci set ice.cloud.enabled="1"
				uci set ice.cloud.server="$privopt225"
			fi
		fi
		if [ -n "$privopt226" ]; then
			echo "dhcp option 226: $privopt226" >/dev/console
			[ -z "$(uci get -q ice.dhcp)" ] && uci set ice.dhcp="dhcp"
			uci set ice.dhcp.opt226connectionid="$privopt226"
			ubus send dhcp.opt226connectionid '{"opt226connectionid":"","value":"'$privopt226'"}'
		fi
		uci commit
	fi

	exit 0
fi

local iupurl
local configurl
local software
local sofwareminuspath

config_load provisioning
#check if iup should be used or if its overridden by /etc/config
config_get configurl configserver	url
config_get reboot configserver reboot
config_get iupurl iup	urliup

if [ $configurl ]; then
	handle_provisioning configserver "0"
elif [ $iupurl ]; then
	handle_provisioning iup "1"
else
	v "No Provisioning Server Found"
	exit
fi

config_load provisioning
config_foreach handle_provisioning subconfig "0"
config_get software uppgradeserver url
sofwareminuspath=${software##*/}
v "Software version to download $sofwareminuspath"

if [ $software ]; then
	local sysinfo=$(ubus call router.system info)
	json_load "$sysinfo"
	json_select system
	json_get_var firmware firmware
	json_get_var filesystem filesystem
        if [ "$filesystem" == "JFFS2" ] ; then
                firmware=$firmware.w
        else
                firmware=$firmware.y
        fi
	if [ "$sofwareminuspath" == "${sofwareminuspath/$firmware/}" ] ; then
		echo $software
		handle_provisioning uppgradeserver "0"
	else
		v "Will not update software, already up to date"
	fi
fi

if [ $CONF -eq 1 ]; then
	mv "$IUPMD5.temp" $IUPMD5
fi

if [ "$reboot" == "on" ]; then
	v "Rebooting"
	export REBOOT_REASON=iup
	/sbin/reboot
fi

rm -rf /var/run/iup.pid
