#!/bin/sh /etc/rc.common

START=99
STOP=10

USE_PROCD=1
PROG=/usr/sbin/ieee1905d
MESH_CONF=/tmp/meshcomms.config
INTERFACE=""

validate_global_section()
{
	uci_validate_section ieee1905 meshcomms "${1}" \
		'enabled:bool:false' \
		'basemacint:string:wan' \
		'almac:string' \
		'registrar:string' \
		'mapall:bool:true' \
		'debug_level:uinteger:5' \
		'port:port:8888' \
		'cmdu_event:bool:true'
}

validate_ieee1905_section()
{
	uci_validate_section ieee1905 ieee1905 "${1}" \
		'debug:bool:true' \
		'enabled:bool:true'
}

get_device_name() {
	local device
	# Get wan L3 interface
	ubus list |grep -iq network.interface.${1}
	if [ "$?" -eq 0 ]; then
		json_load "$(ubus -t 2 call network.interface.${1} status)"
		json_get_var device device
		echo ${device}
	fi
}

get_interface_mac() {
	local l3 basemac
	l3=$(get_device_name ${1})
	if [ -n ${l3} ]; then
		json_load "$(ubus -t 2 call network.device status "{\"name\":\"${l3}\"}")"
		json_get_var basemac macaddr
	fi
	local first=0x$(echo $basemac |cut -d : -f 1)
	local rest=$(echo $basemac |cut -d : -f 2-)
	# Set local bit
	first=$((first|2))
	first=$(printf "%02x" $first)
	basemac="${first}:${rest}"
	echo ${basemac}
}

validate_al_section()
{
	uci_validate_section ieee1905 al-iface "${1}" \
		'enabled:bool:false' \
		'ifname:string' \
		'media:string:eth' \
		'manufacturer_name:string:iopsys' \
		'model_name:string' \
		'model_number:string' \
		'device_name:string'
}

configure_interface()
{
	local ifname media enabled manufacturer_name model_name model_number device_name
	validate_al_section ${1} || {
		echo "Validation of global section failed"
		return 1;
	}

	if [ ${enabled} -eq 0 ]; then
		return;
	fi

	if [ -z ${INTERFACE} ]; then
		INTERFACE=${ifname}
	else
		INTERFACE="${INTERFACE},${ifname}"
	fi

	json_add_object
	json_add_string ifname ${ifname}
	json_add_string media ${media}
	json_add_string manufacturer_name ${manufacturer_name}
	json_add_string model_name ${model_name}
	json_add_string model_number ${model_number}
	json_add_string device_name ${device_name}
	json_close_object
}

configure_meshcomms()
{
	local enabled almac basemacint mapall debug_level port l3device basemac intf registrar cmdu_event

	validate_global_section global || {
		echo "Validation of global section failed"
		return 1;
	}

	if [ -z ${almac} ]; then
		basemac=$(get_interface_mac ${basemacint})
	else
		basemac=${almac}
	fi


	local fname cname model cUrl
	fname=$(db get hw.board.boardId)
	cname=$(db get hw.board.iopVerCustomer)
	model=$(db get hw.board.routerModel)
	cUrl="http://192.168.1.1"

	json_init
	# fill the al-iface info
	json_add_array al-iface
	config_foreach configure_interface al-iface
	json_close_array
	json_add_object deviceInfo
	json_add_string friendly_name ${fname}
	json_add_string manufacturer_name ${cname}
	json_add_string model ${model}
	json_add_string control_url ${cUrl}
	json_close_object
	json_add_object meshcomms
	json_add_int enabled ${enabled}
	json_add_string mac ${basemac}
	json_add_string interfaces ${INTERFACE}
	json_add_int map ${mapall}
	json_add_string registrar ${registrar}
	json_add_int debug_level ${debug_level}
	json_add_int port ${port}
	json_add_int cmdu_event ${cmdu_event}
	json_close_object

	json_dump >${MESH_CONF}

}

configure_ieee1905()
{
	local enabled debug

	validate_ieee1905_section ${1} || {
		echo "Validation of ieee1905 section failed"
		exit 1;
	}

	if [ ${debug} -eq 1 ]; then
		# Forward stdout of the command to logd
		procd_set_param stdout 1
		# Same for stderr
		procd_set_param stderr 1
	fi

	if [ ${enabled} -ne 1 ]; then
		exit 0;
	fi
}

configure_network() {
	[ -f ${MESH_CONF} ] && rm ${MESH_CONF}

	ebtables -L FORWARD|grep -iqE "1:80:C2:(0)+:(0)+:13.*-j.*DROP"
	if [ "$?" -ne 0 ]; then
		echo "Applying drop rule to drop pkts forwared by kernel to 1905.1 multicast mac"
		ebtables -A FORWARD -d 01:80:c2:00:00:13 -j DROP
	fi

	config_load ieee1905
	config_foreach configure_ieee1905 ieee1905
	config_foreach configure_meshcomms meshcomms
}

start_service() {
	procd_open_instance ieee1905
	procd_set_param command ${PROG}
	configure_network
	procd_set_param respawn
	procd_close_instance
}

reload_service() {
	stop
	start
}

service_triggers() {
	procd_add_reload_trigger "network"
	procd_add_reload_trigger "netmode"
}
